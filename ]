use bevy::prelude::*;

use crate::plugins::game_ui::map::MapUiData;
use crate::{config::TILE_SIZE, plugins::input::movement::click_move::MovementPath};

#[derive(Resource, Clone, Copy)]
pub struct MovePathFrameData {
    pub frame_root: Entity,
}

#[derive(Event, Resource, Clone)]
pub struct PathSpriteEvent {
    pub frame_root: Option<Entity>,
    pub action: SpriteAction,
}

impl From<SpriteAction> for PathSpriteEvent {
    fn from(value: PathSpriteAction) -> Self {
        Self {
            frame_root: None,
            action: value,
        }
    }
}

#[derive(Clone, Copy)]
pub enum SpriteAction {
    Spawn,
    Despawn,
}

/// Create a Node for the whole window which will be used as reference for
/// placement of the focus box sprite.
pub fn setup(map_ui_data: Res<MapUiData>, mut commands: Commands) {
    let move_path_frame = commands
        .spawn((
            NodeBundle {
                background_color: Color::NONE.into(),
                ..Default::default()
            },
            Name::new("Map Focus Box Root Node"),
        ))
        .set_parent(map_ui_data.map_ui_sprites_root)
        .id();

    commands.insert_resource::<MovePathFrameData>(MovePathFrameData {
        frame_root: move_path_frame,
    });
}

/// Spawns the a solid line running through the center of the squares along a
/// MovePath. The spawned rectangular sprites are all set to be the children
/// of Entity stored in the MovePathFrameData resource.
pub fn spawn_move_path(
    commands: &mut Commands,
    move_path: &MovementPath,
    move_path_frame: Res<MovePathFrameData>,
) {
    let offset: Vec3 = Vec3::new(TILE_SIZE / 2.0, TILE_SIZE / 2.0, 0.120);
    // Rectangle
    for step in &move_path.path {
        let is_horizontal = step.0.x + TILE_SIZE == step.1.x || step.0.x - TILE_SIZE == step.1.x;
        let is_vertical = step.0.y + TILE_SIZE == step.1.y || step.0.x - TILE_SIZE == step.1.y;
        if is_horizontal {
            let signed_offset_x = if (step.1.x - step.0.x).is_sign_positive() {
                offset.x
            } else {
                -1.0 * offset.x
            };
            let transform_x = step.0.x + signed_offset_x;
            commands
                .spawn(SpriteBundle {
                    sprite: Sprite {
                        // TODO: Put this color in a const somewhere
                        color: Color::rgb(0.25, 0.25, 0.75),
                        custom_size: Some(Vec2::new(TILE_SIZE, 5.0)),
                        ..default()
                    },
                    transform: Transform::from_translation(Vec3::new(transform_x, 0.0, offset.z)),
                    ..default()
                })
                .set_parent(move_path_frame.frame_root);
        } else if is_vertical {
            let signed_offset_y = if (step.1.y - step.0.y).is_sign_positive() {
                offset.y
            } else {
                -1.0 * offset.y
            };
            let transform_y = step.0.y + signed_offset_y;
            commands
                .spawn(SpriteBundle {
                    sprite: Sprite {
                        // TODO: Put this color in a const somewhere
                        color: Color::rgb(0.25, 0.25, 0.0),
                        custom_size: Some(Vec2::new(5.0, TILE_SIZE)),
                        ..default()
                    },
                    transform: Transform::from_translation(Vec3::new(0.0, transform_y, offset.z)),
                    ..default()
                })
                .set_parent(move_path_frame.frame_root);
        }
    }
}

/// Despawns a move path by recursively despawning the children of the Entity
/// stored in the resource `Res<MovePathFrameData>`.
/// The resource itself is despawned in the cleanup function of the containing
/// map crate.
pub fn despawn_move_path(mut commands: Commands, move_path_frame: Res<MovePathFrameData>) {
    commands
        .entity(move_path_frame.frame_root)
        .despawn_descendants();
}
